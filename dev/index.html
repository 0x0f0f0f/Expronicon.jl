<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start · Expronicon.jl</title><link rel="canonical" href="https://Roger-luo.github.io/Expronicon.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/main.css" rel="stylesheet" type="text/css"/><link href="assets/default.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Expronicon.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Quick Start</a><ul class="internal"><li><a class="tocitem" href="#Builtin-Syntax-Types"><span>Builtin Syntax Types</span></a></li><li><a class="tocitem" href="#Pattern-Matching"><span>Pattern Matching</span></a></li><li><a class="tocitem" href="#Analysis-Functions"><span>Analysis Functions</span></a></li><li><a class="tocitem" href="#Transform-Functions"><span>Transform Functions</span></a></li><li><a class="tocitem" href="#Code-Generation-Functions"><span>Code Generation Functions</span></a></li><li><a class="tocitem" href="#Pretty-Printing"><span>Pretty Printing</span></a></li></ul></li><li><a class="tocitem" href="case/">Case Study</a></li><li><a class="tocitem" href="reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick Start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick Start</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Roger-luo/Expronicon.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Expronicon"><a class="docs-heading-anchor" href="#Expronicon">Expronicon</a><a id="Expronicon-1"></a><a class="docs-heading-anchor-permalink" href="#Expronicon" title="Permalink"></a></h1><p><a href="https://Roger-luo.github.io/Expronicon.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> <a href="https://Roger-luo.github.io/Expronicon.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/Roger-luo/Expronicon.jl/actions"><img src="https://github.com/Roger-luo/Expronicon.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://codecov.io/gh/Roger-luo/Expronicon.jl"><img src="https://codecov.io/gh/Roger-luo/Expronicon.jl/branch/master/graph/badge.svg" alt="Coverage"/></a> <a href="https://github.com/Roger-luo/Expronicon.jl/actions/workflows/Downstream.yml"><img src="https://github.com/Roger-luo/Expronicon.jl/actions/workflows/Downstream.yml/badge.svg" alt="Downstream"/></a></p><p>Collective tools for metaprogramming on Julia Expr, the meta programming standard library for <a href="https://thautwarm.github.io/MLStyle.jl/latest/">MLStyle</a>.</p><p>Meta programming in general can be decomposed into three steps:</p><ol><li>analyse the given expression</li><li>transform the given expression to:<ul><li>another target expression</li><li>a convenient intermediate representation (IR) that is easy to further manipulate/analyse</li></ul></li><li>generate the target code, the target code can be:<ul><li>most commonly the Julia <code>Expr</code></li><li>another language&#39;s abstract/concrete syntax tree</li><li>a lower-level IR</li></ul></li></ol><p>The package <code>Expronicon</code> is thus written to assist you writing meta programs in the above manner.</p><h2 id="Builtin-Syntax-Types"><a class="docs-heading-anchor" href="#Builtin-Syntax-Types">Builtin Syntax Types</a><a id="Builtin-Syntax-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Builtin-Syntax-Types" title="Permalink"></a></h2><p>One of the most important tool in <code>Expronicon</code> is the <strong>syntax types</strong>, these are types describing a specific Julia syntax, e.g <code>JLFunction</code> describes Julia&#39;s function definition syntax. The syntax type uses a canonical data structure to represent various syntax that has the same semantic, which is convenient when one wants to manipulate, generate such objects.</p><p>They will allow you to:</p><ol><li>easily analysis a given Julia <code>Expr</code> by converting it to the syntax type</li><li>easily manipulate a given Julia <code>Expr</code> with data structure designed for easier manipulation</li><li>easily generate a Julia <code>Expr</code> using <a href="reference/#Expronicon.codegen_ast-Tuple{Any}"><code>codegen_ast</code></a>.</li></ol><p>Let&#39;s take <code>JLFunction</code> as our example again, in Julia, function can be declared in many different ways:</p><p>You can define a function using the short form</p><pre><code class="language-julia">f(x) = x</code></pre><p>or you can declare the same function using the <code>function</code> keyword</p><pre><code class="language-julia">function f(x)
    return x
end</code></pre><p>If we look at their expression object, we will find they actually have quite different expression structure:</p><pre><code class="language-julia">ex1 = @expr f(x) = x</code></pre><pre class="documenter-example-output">:(f(x) = begin
          #= none:1 =#
          x
      end)</pre><pre><code class="language-julia">ex2 = @expr function f(x)
    return x
end</code></pre><pre class="documenter-example-output">:(function f(x)
      #= none:1 =#
      #= none:2 =#
      return x
  end)</pre><p>here we use a convenient tool to obtain the Julia expression object provided by <code>Expronicon</code>, the <a href="reference/#Expronicon.@expr-Tuple{Any, Any}"><code>@expr</code></a> macro.</p><p>Now if we convert them to the <code>JLFunction</code> type</p><pre><code class="language-julia">jl1 = JLFunction(ex1)</code></pre><pre class="terminal-output">f(x) = begin
    #= none:1 =#    
    x    
end</pre><pre><code class="language-julia">jl2 = JLFunction(ex2)</code></pre><pre class="terminal-output">function f(x)
    #= none:1 =#    
    #= none:2 =#    
    return x    
end</pre><p>we can see they have the same structure under the representation of <a href="reference/#Expronicon.JLFunction"><code>JLFunction</code></a>.</p><pre><code class="language-julia">dump(jl1)</code></pre><pre class="documenter-example-output">JLFunction
  head: Symbol =
  name: Symbol f
  args: Array{Any}((1,))
    1: Symbol x
  kwargs: Nothing nothing
  whereparams: Nothing nothing
  body: Expr
    head: Symbol block
    args: Array{Any}((2,))
      1: LineNumberNode
        line: Int64 1
        file: Symbol none
      2: Symbol x
  line: Nothing nothing
  doc: Nothing nothing</pre><pre><code class="language-julia">dump(jl2)</code></pre><pre class="documenter-example-output">JLFunction
  head: Symbol function
  name: Symbol f
  args: Array{Any}((1,))
    1: Symbol x
  kwargs: Nothing nothing
  whereparams: Nothing nothing
  body: Expr
    head: Symbol block
    args: Array{Any}((3,))
      1: LineNumberNode
        line: Int64 1
        file: Symbol none
      2: LineNumberNode
        line: Int64 2
        file: Symbol none
      3: Expr
        head: Symbol return
        args: Array{Any}((1,))
          1: Symbol x
  line: Nothing nothing
  doc: Nothing nothing</pre><p>we can easily access to some important information of this function by accessing the fields</p><pre><code class="language-julia-repl">julia&gt; jl1.name
:f

julia&gt; jl1.args
1-element Vector{Any}:
 :x

julia&gt; jl1.body
quote
    #= none:1 =#
    x
end</code></pre><p>This is the same for other syntax types, e.g we can get the corresponding syntax type instance of a struct definition</p><pre><code class="language-julia">def = @expr JLStruct struct Foo{T} &lt;: AbstractType
    x::Int
    y::T
end</code></pre><pre class="terminal-output">struct Foo{T} &lt;: AbstractType
    #= none:2 =#
    x::Int
    #= none:3 =#
    y::T
end</pre><p>we again use <a href="reference/#Expronicon.@expr-Tuple{Any, Any}"><code>@expr</code></a> for convenience, however you can also just convert the expression to <code>JLStruct</code> manually</p><pre><code class="language-julia">ex = quote
    struct Foo{T} &lt;: AbstractType
        x::Int
        y::T
    end
end
def = JLStruct(ex.args[2])</code></pre><pre class="terminal-output">struct Foo{T} &lt;: AbstractType
    #= none:3 =#
    x::Int
    #= none:4 =#
    y::T
end</pre><p>once you have the corresponding <code>JLStruct</code> object, you can access many useful information directly</p><pre><code class="language-julia-repl">julia&gt; def.name
:Foo

julia&gt; def.typevars
1-element Vector{Any}:
 :T

julia&gt; def.supertype
:AbstractType

julia&gt; typeof(def.fields[1])
JLField

julia&gt; def.fields[1].name
:x

julia&gt; def.fields[1].type
:Int</code></pre><p>Some syntax types are defined for easy manipulation such as <a href="reference/#Expronicon.JLIfElse"><code>JLIfElse</code></a>, Julia&#39;s representation of <code>if ... elseif ... else ... end</code> statement is a recursive tree in <code>Expr</code>, which sometimes is not very convenient to manipulate or analysis, for example, it is not easy to access all the conditions in a long <code>ifelse</code> statement</p><pre><code class="language-julia">ex = @expr if x &gt; 100
    x + 1
elseif x &gt; 90
    x + 2
elseif x &gt; 80
    x + 3
else
    error(&quot;some error msg&quot;)
end</code></pre><pre class="documenter-example-output">:(if x &gt; 100
      #= none:2 =#
      x + 1
  elseif #= none:3 =# x &gt; 90
      #= none:4 =#
      x + 2
  elseif #= none:5 =# x &gt; 80
      #= none:6 =#
      x + 3
  else
      #= none:8 =#
      error(&quot;some error msg&quot;)
  end)</pre><p>we can find each condition</p><pre><code class="language-julia-repl">julia&gt; ex.args[1]
:(x &gt; 100)

julia&gt; ex.args[3].args[1]
quote
    #= none:3 =#
    x &gt; 90
end

julia&gt; ex.args[3].args[3].args[1]
quote
    #= none:5 =#
    x &gt; 80
end

julia&gt; ex.args[3].args[3].args[3]
quote
    #= none:8 =#
    error(&quot;some error msg&quot;)
end</code></pre><p>imagine how would you construct such expression from scratch, or how would you access all the conditions. Thus <a href="reference/#Expronicon.JLIfElse"><code>JLIfElse</code></a> allows you to access/manipulate <code>ifelse</code> statements directly as a dict-like object</p><pre><code class="language-julia-repl">julia&gt; jl = JLIfElse(ex);

julia&gt; jl.map
OrderedCollections.OrderedDict{Any, Any} with 3 entries:
  :(x &gt; 100)                            =&gt; quote…
  quote…                                =&gt; quote…
  quote…                                =&gt; quote…

julia&gt; jl.otherwise
quote
    #= none:8 =#
    error(&quot;some error msg&quot;)
end</code></pre><p>you can access to each condition and its action using the condition as your key</p><pre><code class="language-julia-repl">julia&gt; jl.map[:(x &gt; 100)]
quote
    #= none:2 =#
    x + 1
end</code></pre><p>similarly, we can easily construct a <code>JLIfElse</code></p><pre><code class="language-julia">jl = JLIfElse()
jl.map[:(x &gt; 100)] = :(x + 1)
jl.map[:(x &gt; 80)] = :(x + 2)
jl.otherwise = :(error(&quot;some error msg&quot;))
jl</code></pre><pre class="terminal-output">if &gt;(x, 100)
    x + 1
elseif &gt;(x, 80)
    x + 2
else
    error(&quot;some error msg&quot;)
end</pre><p>now let&#39;s generate back to <code>Expr</code> so that we can give Julia back some executable expression</p><pre><code class="language-julia-repl">julia&gt; codegen_ast(jl)
:(if x &gt; 100
      x + 1
  elseif x &gt; 80
      x + 2
  else
      error(&quot;some error msg&quot;)
  end)</code></pre><p>You can find available syntax types in <a href="reference/#Syntax-Types">Syntax Types</a></p><h2 id="Pattern-Matching"><a class="docs-heading-anchor" href="#Pattern-Matching">Pattern Matching</a><a id="Pattern-Matching-1"></a><a class="docs-heading-anchor-permalink" href="#Pattern-Matching" title="Permalink"></a></h2><p>Since <code>Expronicon</code> serves as the meta programming stdlib for MLStyle, you can also use the syntax types along with MLStyle, e.g</p><pre><code class="language-julia">using MLStyle
using Expronicon

f = @λ begin
   JLFunction(;name=:foo, args) =&gt; (args, )
   JLFunction(;name=:boo, args) =&gt; (args, )
   _ =&gt; nothing
end

ex_foo = @expr function foo(x::Int, y::T) where {T &lt;: Real}
    x + y
end

ex_boo = @expr function foo(x::Int)
    x
end</code></pre><p>then we can check if our match function gives the right result</p><pre><code class="language-julia-repl">julia&gt; f(ex_foo)
(Any[:(x::Int), :(y::T)],)

julia&gt; f(ex_boo)
(Any[:(x::Int)],)</code></pre><p>You can use <strong>any</strong> syntax types builtin as your expression template to match using MLStyle. If you define your own syntax type, you can also support pattern matching via <a href="#Expronicon.@syntax_pattern"><code>@syntax_pattern</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Expronicon.@syntax_pattern" href="#Expronicon.@syntax_pattern"><code>Expronicon.@syntax_pattern</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@syntax_pattern &lt;syntax type&gt; &lt;syntax checker&gt;</code></pre><p><strong>Example</strong></p><pre><code class="language-julia">struct MyFunction
    ex :: Expr
    test_field :: Any
end

is_xxx(ex::Expr) = Meta.isexpr(ex, :function)
is_xxx(_) = false

julia&gt; MyFunction(ex::Expr) = MyFunction(ex, :aaa)
julia&gt; @syntax_pattern(MyFunction, is_xxx)

julia&gt; @match :(function f() end) begin
        MyFunction(;test_field) =&gt; test_field
    end
:aaa</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Expronicon.jl/blob/2bc7c82445e4fb152aa23f4ff575de0eb54b30f6/src/match.jl#L1-L23">source</a></section></article><h2 id="Analysis-Functions"><a class="docs-heading-anchor" href="#Analysis-Functions">Analysis Functions</a><a id="Analysis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-Functions" title="Permalink"></a></h2><p><code>Expronicon</code> provides a lot common analysis functions, you can find the list of them in <a href="reference/#Analysis">Analysis</a>. you can use them to check if the expression satisfy certain property, e.g you can check if a given object is a struct definition via <a href="reference/#Expronicon.is_struct-Tuple{Any}"><code>is_struct</code></a>, or check if a given function definition supports keyword arguments via <a href="reference/#Expronicon.is_kw_function-Tuple{Any}"><code>is_kw_function</code></a>.</p><h2 id="Transform-Functions"><a class="docs-heading-anchor" href="#Transform-Functions">Transform Functions</a><a id="Transform-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Transform-Functions" title="Permalink"></a></h2><p>You can find the list of them in <a href="reference/#Transform">Transform</a>.</p><p>Transform functions usually takes an expression and returns an expression e.g sometimes you only want the name symbol of your function arguments</p><pre><code class="language-julia">def = @expr JLFunction function foo(x::Int, y::Real=2)
end</code></pre><pre><code class="language-julia-repl">julia&gt; def.args
2-element Vector{Any}:
 :(x::Int)
 :($(Expr(:kw, :(y::Real), 2)))

julia&gt; name_only.(def.args)
2-element Vector{Symbol}:
 :x
 :y</code></pre><h2 id="Code-Generation-Functions"><a class="docs-heading-anchor" href="#Code-Generation-Functions">Code Generation Functions</a><a id="Code-Generation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Generation-Functions" title="Permalink"></a></h2><p>The code generation functions help you generate other target expressions, e.g <a href="reference/#Expronicon.codegen_ast-Tuple{Any}"><code>codegen_ast</code></a> generates the Julia AST object <code>Expr</code>. All the syntax type can use <a href="reference/#Expronicon.codegen_ast-Tuple{Any}"><code>codegen_ast</code></a> to generate the corresponding <code>Expr</code>, there are also some other functions start with name <code>codegen</code> in <a href="reference/#CodeGen">CodeGen</a> you may find useful.</p><h2 id="Pretty-Printing"><a class="docs-heading-anchor" href="#Pretty-Printing">Pretty Printing</a><a id="Pretty-Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Pretty-Printing" title="Permalink"></a></h2><p>Sometimes, when you define your own intermediate representation, you may want to pretty print your expression with colors and indents. <code>Expronicon</code> also provide some tools for this in <a href="reference/#Printings">Printings</a>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="case/">Case Study »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 8 April 2021 21:17">Thursday 8 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
